function! s:on_stderr(data) abort dict
  for line in a:data
    call themis#log(line)
  endfor
endfunction

function! s:on_receive_raw(data) abort dict
  let self._received[-1] .= a:data[0]
  call extend(self._received, a:data[1:])
endfunction

function! s:on_receive_text(data) abort dict
  let data = map(copy(a:data), { k, v -> substitute(v, '\r$', '', '') })
  let self._received[-1] .= data[0]
  call extend(self._received, data[1:])
endfunction

Describe System.Job
  Before all
    let python = exists('$PYTHON3') ? expand('$PYTHON3') : 'python3'
    let Job = vital#vital#import('System.Job')
    let Path = vital#vital#import('System.Filepath')
    let root = Path.realpath('test/_testdata/System/Job')

    function! Lines(...) abort
      return join(a:000, "\n")
    endfunction
  End

  Before
    if !Job.is_available()
      Skip System.Job requires Neovim with patch-7.4.1646 or Vim with patch-8.0.0027
    endif
  End

  Describe .start({cmd}[, {options}])
    It starts a job with {cmd} and return a job instance
      let path = Path.join(root, 'echo.py')
      let job = Job.start([python, path])
      Assert KeyExists(job, 'status')
      Assert KeyExists(job, 'wait')
      Assert KeyExists(job, 'send')
      Assert KeyExists(job, 'stop')
    End

    It throws an exception when {args} is not a List instance
      Throws /Argument requires to be a List instance/ Job.start(python)
    End

    It throws an exception when {args} is an empty list
      Throws /Argument vector must have at least one item/ Job.start([])
    End

    It throws an exception when a first item of {args} is not executable
      Throws /"foo" is not an executable/ Job.start(['foo'])
    End
  End

  Describe An instance
    Describe .on_stdout() callback
      Before
        let options = {
              \ '_received': [''],
              \ 'on_stdout': function('s:on_receive_raw'),
              \ 'on_stderr': function('s:on_stderr'),
              \}
      End

      It is called with raw {data} (CR)
        let path = Path.join(root, 'echo.py')
        let job = Job.start([python, path, 'stdout', 'cr'], options)
        let exitcode = job.wait(5000)
        Assert Equals(exitcode, 0)
        Assert Equals(job._received, [
              \ "Hello World\rHello World\rThis is not line",
              \])
      End

      It is called with raw {data} (LF)
        let path = Path.join(root, 'echo.py')
        let job = Job.start([python, path, 'stdout', 'lf'], options)
        let exitcode = job.wait(5000)
        Assert Equals(exitcode, 0)
        Assert Equals(job._received, [
              \ 'Hello World',
              \ 'Hello World',
              \ 'This is not line',
              \])
      End

      It is called with raw {data} (CRLF)
        let path = Path.join(root, 'echo.py')
        let job = Job.start([python, path, 'stdout', 'crlf'], options)
        let exitcode = job.wait(5000)
        Assert Equals(exitcode, 0)
        Assert Equals(job._received, [
              \ "Hello World\r",
              \ "Hello World\r",
              \ 'This is not line',
              \])
      End
    End

    Describe .on_stderr() callback
      Before
        let options = {
              \ '_received': [''],
              \ 'on_stderr': function('s:on_receive_raw'),
              \}
      End

      It is called with raw {data} (CR)
        let path = Path.join(root, 'echo.py')
        let job = Job.start([python, path, 'stderr', 'cr'], options)
        let exitcode = job.wait(5000)
        Assert Equals(exitcode, 0)
        Assert Equals(job._received, [
              \ "Hello World\rHello World\rThis is not line",
              \])
      End

      It is called with raw {data} (LF)
        let path = Path.join(root, 'echo.py')
        let job = Job.start([python, path, 'stderr', 'lf'], options)
        let exitcode = job.wait(5000)
        Assert Equals(exitcode, 0)
        Assert Equals(job._received, [
              \ 'Hello World',
              \ 'Hello World',
              \ 'This is not line',
              \])
      End

      It is called with raw {data} (CRLF)
        let path = Path.join(root, 'echo.py')
        let job = Job.start([python, path, 'stderr', 'crlf'], options)
        let exitcode = job.wait(5000)
        Assert Equals(exitcode, 0)
        Assert Equals(job._received, [
              \ "Hello World\r",
              \ "Hello World\r",
              \ 'This is not line',
              \])
      End
    End

    Describe .on_exit() callback
      Before
        function! s:on_exit(exitcode) abort dict
          call add(self._exitcode, a:exitcode)
        endfunction

        let options = {
              \ '_exitcode': [],
              \ 'on_exit': function('s:on_exit'),
              \}
      End

      It is called with an exitcode
        let path = Path.join(root, 'exitval.py')
        let job = Job.start([python, path, '0'], options)
        Assert Equals(job.wait(), 0)
        Assert Equals(job._exitcode, [0])

        let job = Job.start([python, path, '1'], options)
        Assert Equals(job.wait(), 1)
        Assert Equals(job._exitcode, [0, 1])

        let job = Job.start([python, path, '2'], options)
        Assert Equals(job.wait(), 2)
        Assert Equals(job._exitcode, [0, 1, 2])
      End
    End

    Describe .id()
      It returns a unique number for individual process
        let path = Path.join(root, 'infinity_loop.py')
        let job1 = Job.start([python, path])
        let job2 = Job.start([python, path])
        Assert IsNumber(job1.id())
        Assert IsNumber(job2.id())
        Assert NotEqual(job1.id(), job2.id())
        call job1.stop()
        call job2.stop()
      End
    End

    Describe .status()
      It returns 'run' and 'dead' when the job alive or dead respectively
        let path = Path.join(root, 'infinity_loop.py')
        let job = Job.start([python, path])
        Assert Equals(job.status(), 'run')
        call job.stop()
        call job.wait()
        Assert Equals(job.status(), 'dead')
      End
    End

    Describe .send({data})
      Before
        let options = {
              \ '_received': [''],
              \ 'on_stdout': function('s:on_receive_text'),
              \}
      End

      It sends {data} (String) to the job process on Unix
        let path = Path.join(root, 'input.py')
        let job = Job.start([python, path], options)
        call job.send("lambdalisue\n")
        call job.wait()
        Assert Equals(job.status(), 'dead')
        Assert Equals(job._received, ['Please input your name: Hello lambdalisue', ''])
      End

      It sends {data} (List) to the job process on Unix
        let path = Path.join(root, 'read.py')
        let job = Job.start([python, path], options)
        call job.send(['abc', "123\n456", ''])
        call job.send(['.', ''])
        call job.wait()
        Assert Equals(job.status(), 'dead')
        if has('nvim')
          Assert Equals(job._received, [
                \ 'read:',
                \ 'abc',
                \ '123<NUL>456',
                \ '',
                \ '',
                \])
        else
          " Vim cannot send \0
          Assert Equals(job._received, [
                \ 'read:',
                \ 'abc',
                \ '123456',
                \ '',
                \ '',
                \])
        endif
      End
    End

    Describe .stop()
      It stop a job which is running
        let path = Path.join(root, 'infinity_loop.py')
        let job = Job.start([python, path])
        Assert Equals(job.status(), 'run')
        call job.stop()
        " Wait 1 sec to make sure the process termination
        sleep 1
        Assert Equals(job.status(), 'dead')
        " The following should not raise exception
        call job.stop()
      End
    End

    Describe .wait([{timeout}])
      It waits a job to terminate
        let path = Path.join(root, '2sec.py')
        let job = Job.start([python, path])
        let start = reltime()
        let status = job.wait()
        let delta = reltime(start)
        Assert Equals(status, 0)
        Assert Equals(job.status(), 'dead')
        Assert Compare(reltimefloat(delta), '>', 2.0)
      End

      It returns an exit status when the job has terminated
        let path = Path.join(root, 'exitval.py')
        let job = Job.start([python, path, '0'])
        Assert Equals(job.wait(), 0)

        let job = Job.start([python, path, '1'])
        Assert Equals(job.wait(), 1)

        let job = Job.start([python, path, '2'])
        Assert Equals(job.wait(), 2)
      End

      It returns -1 when the job did not terminate within {timeout}
        let script = Path.join(root, 'infinity_loop.py')
        let job = Job.start([python, script])
        let start = reltime()
        let status = job.wait(10)
        let delta = reltime(start)
        Assert Equals(status, -1)
        Assert Equals(job.status(), 'run')
        Assert Compare(reltimefloat(delta), '>', 0.01)
        Assert Compare(reltimefloat(delta), '<', 0.05)
        " Kill the process
        call job.stop()
        " Wait 1 sec to make sure the process termination
        sleep 1
        Assert Equals(job.status(), 'dead')
      End
    End
  End
End
