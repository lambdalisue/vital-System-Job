let s:is_windows = has('win32') || has('win64')
let s:newline = s:is_windows ? "\r\n" : "\n"

Describe System.Job
  Before all
    let Job = vital#vital#import('System.Job')
    let Path = vital#vital#import('System.Filepath')
    let root = Path.realpath('test/_testdata/System/Job')
    let newline = s:newline

    function! Lines(...) abort
      return join(a:000, s:newline)
    endfunction
  End

  Before
    if !Job.is_available()
      Skip System.Job requires Neovim with patch-7.4.1646 or Vim with patch-8.0.0027
    endif
  End

  Describe .start({cmd}[, {options}])
    It starts a job with {cmd} and return a job instance
      let path = Path.join(root, 'echo_stdout.py')
      let job = Job.start(['python', path])
      Assert KeyExists(job, 'status')
      Assert KeyExists(job, 'wait')
      Assert KeyExists(job, 'send')
      Assert KeyExists(job, 'stop')
    End

    It throws an exception when {args} is not a List instance
      Throws /Argument requires to be a List instance/ Job.start('python')
    End

    It throws an exception when {args} is an empty list
      Throws /Argument vector must have at least one item/ Job.start([])
    End

    It throws an exception when a first item of {args} is not executable
      Throws /"foo" is not an executable/ Job.start(['foo'])
    End
  End

  Describe An instance
    Describe .on_stdout() callback
      Before
        function! s:on_stdout(data) abort dict
          let self._stdout[-1] .= a:data[0]
          call extend(self._stdout, a:data[1:])
        endfunction

        let options = {
              \ '_stdout': [''],
              \ 'on_stdout': function('s:on_stdout'),
              \}
      End

      It is called with raw {data} (CR)
        let path = Path.join(root, 'echo.py')
        let job = Job.start(['python', path, 'stdout', 'cr'], options)
        let exitcode = job.wait(5000)
        Assert Equals(exitcode, 0)
        Assert Equals(job._stdout, [
              \ "Hello World\rHello World\rThis is not line",
              \])
      End

      It is called with raw {data} (LF)
        let path = Path.join(root, 'echo.py')
        let job = Job.start(['python', path, 'stdout', 'lf'], options)
        let exitcode = job.wait(5000)
        Assert Equals(exitcode, 0)
        if s:is_windows
          Assert Equals(job._stdout, [
                \ "Hello World\nHello World\nThis is not line",
                \])
        else
          Assert Equals(job._stdout, [
                \ 'Hello World',
                \ 'Hello World',
                \ 'This is not line',
                \])
        endif
      End

      It is called with raw {data} (CRLF)
        let path = Path.join(root, 'echo.py')
        let job = Job.start(['python', path, 'stdout', 'crlf'], options)
        let exitcode = job.wait(5000)
        Assert Equals(exitcode, 0)
        if s:is_windows
          Assert Equals(job._stdout, [
                \ "Hello World",
                \ "Hello World",
                \ 'This is not line',
                \])
        else
          Assert Equals(job._stdout, [
                \ "Hello World\r",
                \ "Hello World\r",
                \ 'This is not line',
                \])
        endif
      End
    End

    Describe .on_stderr() callback
      Before
        function! s:on_stderr(data) abort dict
          let self._stderr[-1] .= a:data[0]
          call extend(self._stderr, a:data[1:])
        endfunction

        let options = {
              \ '_stderr': [''],
              \ 'on_stderr': function('s:on_stderr'),
              \}
      End

      It is called with raw {data} (CR)
        let path = Path.join(root, 'echo.py')
        let job = Job.start(['python', path, 'stderr', 'cr'], options)
        let exitcode = job.wait(5000)
        Assert Equals(exitcode, 0)
        Assert Equals(job._stderr, [
              \ "Hello World\rHello World\rThis is not line",
              \])
      End

      It is called with raw {data} (LF)
        let path = Path.join(root, 'echo.py')
        let job = Job.start(['python', path, 'stderr', 'lf'], options)
        let exitcode = job.wait(5000)
        Assert Equals(exitcode, 0)
        if s:is_windows
          Assert Equals(job._stderr, [
                \ "Hello World\nHello World\nThis is not line",
                \])
        else
          Assert Equals(job._stderr, [
                \ 'Hello World',
                \ 'Hello World',
                \ 'This is not line',
                \])
        endif
      End

      It is called with raw {data} (CRLF)
        let path = Path.join(root, 'echo.py')
        let job = Job.start(['python', path, 'stderr', 'crlf'], options)
        let exitcode = job.wait(5000)
        Assert Equals(exitcode, 0)
        if s:is_windows
          Assert Equals(job._stderr, [
                \ 'Hello World',
                \ 'Hello World',
                \ 'This is not line',
                \])
        else
          Assert Equals(job._stderr, [
                \ "Hello World\r",
                \ "Hello World\r",
                \ 'This is not line',
                \])
        endif
      End
    End

    Describe .on_exit() callback
      Before
        function! s:on_exit(exitcode) abort dict
          let self._exitcode = get(self, '_exitcode', [])
          call add(self._exitcode, a:exitcode)
        endfunction

        let options = {
              \ 'on_exit': function('s:on_exit'),
              \}
      End

      It is called with an exitcode
        let path = Path.join(root, 'exitval.py')
        let job = Job.start(['python', path, '0'], options)
        Assert Equals(job.wait(), 0)
        Assert Equals(job._exitcode, [0])

        let job = Job.start(['python', path, '1'], options)
        Assert Equals(job.wait(), 1)
        Assert Equals(job._exitcode, [1])

        let job = Job.start(['python', path, '2'], options)
        Assert Equals(job.wait(), 2)
        Assert Equals(job._exitcode, [2])
      End
    End

    Describe .id()
      It returns a unique number for individual process
        let path = Path.join(root, 'infinity_loop.py')
        let job1 = Job.start(['python', path])
        let job2 = Job.start(['python', path])
        Assert IsNumber(job1.id())
        Assert IsNumber(job2.id())
        Assert NotEqual(job1.id(), job2.id())
        call job1.stop()
        call job2.stop()
      End
    End

    Describe .status()
      It returns 'run' and 'dead' when the job alive or dead respectively
        let path = Path.join(root, 'infinity_loop.py')
        let job = Job.start(['python', path])
        Assert Equals(job.status(), 'run')
        call job.stop()
        " Wait 1 sec to make sure the process termination
        sleep 1
        Assert Equals(job.status(), 'dead')
      End
    End

    Describe .send({data})
      Before
        function! s:on_stdout(data) abort dict
          let self._stdout[-1] .= a:data[0]
          call extend(self._stdout, a:data[1:])
        endfunction
        let options = {
              \ '_stdout': [''],
              \ 'on_stdout': function('s:on_stdout'),
              \}
      End

      It sends {data} (String) to the job process
        let path = Path.join(root, 'input.py')
        let job = Job.start(['python', path], options)
        call job.send("lambdalisue\n")
        call job.wait()
        Assert Equals(job.status(), 'dead')
        Assert Equals(job._stdout, ['Please input your name: Hello lambdalisue', ''])
      End

      It sends {data} (List) to the job process
        let path = Path.join(root, 'read.py')
        let job = Job.start(['python', path], options)
        call job.send(['abc', "123\n456", ''])
        call job.send(['.', ''])
        call job.wait()
        Assert Equals(job.status(), 'dead')
        if has('nvim')
          Assert Equals(job._stdout, [
                \ 'read:',
                \ 'abc',
                \ '123<NUL>456',
                \ '',
                \ '',
                \])
        else
          " Vim cannot send \0
          Assert Equals(job._stdout, [
                \ 'read:',
                \ 'abc',
                \ '123456',
                \ '',
                \ '',
                \])
        endif
      End
    End

    Describe .stop()
      It stop a job which is running
        let path = Path.join(root, 'infinity_loop.py')
        let job = Job.start(['python', path])
        Assert Equals(job.status(), 'run')
        call job.stop()
        " Wait 1 sec to make sure the process termination
        sleep 1
        Assert Equals(job.status(), 'dead')
        " The following should not raise exception
        call job.stop()
      End
    End

    Describe .wait([{timeout}])
      It waits a job to terminate
        let path = Path.join(root, '2sec.py')
        let job = Job.start(['python', path])
        let start = reltime()
        let status = job.wait()
        let delta = reltime(start)
        Assert Equals(status, 0)
        Assert Equals(job.status(), 'dead')
        Assert Compare(reltimefloat(delta), '>', 2.0)
      End

      It returns an exit status when the job has terminated
        let path = Path.join(root, 'exitval.py')
        let job = Job.start(['python', path, '0'])
        Assert Equals(job.wait(), 0)

        let job = Job.start(['python', path, '1'])
        Assert Equals(job.wait(), 1)

        let job = Job.start(['python', path, '2'])
        Assert Equals(job.wait(), 2)
      End

      It returns -1 when the job did not terminate within {timeout}
        let script = Path.join(root, 'infinity_loop.py')
        let job = Job.start(['python', script])
        let start = reltime()
        let status = job.wait(10)
        let delta = reltime(start)
        Assert Equals(status, -1)
        Assert Equals(job.status(), 'run')
        Assert Compare(reltimefloat(delta), '>', 0.01)
        Assert Compare(reltimefloat(delta), '<', 0.02)
        " Kill the process
        call job.stop()
        " Wait 1 sec to make sure the process termination
        sleep 1
        Assert Equals(job.status(), 'dead')
      End
    End
  End
End
