let s:newline = has('win32') || has('win64') ? "\r\n" : "\n"

Describe System.Job
  Before all
    let Job = vital#vital#import('System.Job')
    let Path = vital#vital#import('System.Filepath')
    let root = Path.realpath('test/_testdata/System/Job')
    let newline = s:newline

    function! Lines(...) abort
      return join(a:000, s:newline)
    endfunction
  End

  Before
    if !Job.is_available()
      Skip This Vim is not supported. System.Job requires Neovim or patch-8.0.0027
    endif
  End

  Describe .start({cmd}[, {options}])
    It starts a job with {cmd} (List) and return a job instance
      let path = Path.join(root, 'echo_stdout.py')
      let job = Job.start(['python3', path])
      Assert KeyExists(job, 'status')
      Assert KeyExists(job, 'wait')
      Assert KeyExists(job, 'send')
      Assert KeyExists(job, 'stop')
    End

    It starts a job with {cmd} (String) and return a job instance
      let path = Path.join(root, 'echo_stdout.py')
      let job = Job.start('python3 ' . shellescape(path))
      Assert KeyExists(job, 'status')
      Assert KeyExists(job, 'wait')
      Assert KeyExists(job, 'send')
      Assert KeyExists(job, 'stop')
    End
  End

  Describe An instance
    Describe .stdout channel
      Describe .read()
        It removes and reads all received data
          let path = Path.join(root, 'echo_stdout.py')
          let job = Job.start(['python3', path])
          let exitcode = job.wait(5000)
          Assert Equals(exitcode, 0)
          Assert Equals(job.stdout.read(), [
                \ 'Hello World',
                \ 'Hello World',
                \ 'This is not line',
                \])
          Assert Equals(job.stdout.read(), v:null)
        End

        It returns v:null if the process does not write data
          let path = Path.join(root, 'infinity_loop.py')
          let job = Job.start(['python3', path])
          Assert Equals(job.status(), 'run')
          Assert Equals(job.stdout.read(), v:null)
          call job.stop()
          call job.wait()
          Assert Equals(job.stdout.read(), v:null)
        End
      End
    End

    Describe .on_stdout() callback
      Before
        function! s:on_stdout(job, data, event) abort dict
          let self._stdout[-1] .= a:data[0]
          call extend(self._stdout, a:data[1:])
        endfunction

        let options = {
              \ '_stdout': [''],
              \ 'on_stdout': function('s:on_stdout'),
              \}
      End

      It removes 'stdout' channel
        let path = Path.join(root, 'exitval.py')
        let job = Job.start(['python3', path, '0'], options)
        Assert KeyNotExists(job, 'stdout')
      End

      It is called with raw {data}
        let path = Path.join(root, 'echo_stdout.py')
        let job = Job.start(['python3', path], options)
        let exitcode = job.wait(5000)
        Assert Equals(exitcode, 0)
        Assert Equals(job._stdout, [
              \ 'Hello World',
              \ 'Hello World',
              \ 'This is not line',
              \])
      End
    End

    Describe .stderr channel
      Describe .read()
        It removes and reads all received data
          let path = Path.join(root, 'echo_stderr.py')
          let job = Job.start(['python3', path])
          let exitcode = job.wait(5000)
          Assert Equals(exitcode, 0)
          Assert Equals(job.stderr.read(), [
                \ 'Hello World',
                \ 'Hello World',
                \ 'This is not line',
                \])
          Assert Equals(job.stderr.read(), v:null)
        End

        It returns v:null if the process does not write data
          let path = Path.join(root, 'infinity_loop.py')
          let job = Job.start(['python3', path])
          Assert Equals(job.status(), 'run')
          Assert Equals(job.stderr.read(), v:null)
          call job.stop()
          call job.wait()
          Assert Equals(job.stderr.read(), v:null)
        End
      End
    End

    Describe .on_stderr() callback
      Before
        function! s:on_stderr(job, data, event) abort dict
          let self._stderr[-1] .= a:data[0]
          call extend(self._stderr, a:data[1:])
        endfunction

        let options = {
              \ '_stderr': [''],
              \ 'on_stderr': function('s:on_stderr'),
              \}
      End

      It removes 'stderr' channel
        let path = Path.join(root, 'exitval.py')
        let job = Job.start(['python3', path, '0'], options)
        Assert KeyNotExists(job, 'stderr')
      End

      It is called with raw {data}
        let path = Path.join(root, 'echo_stderr.py')
        let job = Job.start(['python3', path], options)
        let exitcode = job.wait(5000)
        Assert Equals(exitcode, 0)
        Assert Equals(job._stderr, [
              \ 'Hello World',
              \ 'Hello World',
              \ 'This is not line',
              \])
      End
    End

    Describe .on_exit() callback
      Before
        function! s:on_exit(job, exitcode, event) abort dict
          let self._exitcode = get(self, '_exitcode', [])
          call add(self._exitcode, a:exitcode)
        endfunction

        let options = {
              \ 'on_exit': function('s:on_exit'),
              \}
      End

      It is called with an exitcode
        let path = Path.join(root, 'exitval.py')
        let job = Job.start(['python3', path, '0'], options)
        Assert Equals(job.wait(), 0)
        Assert Equals(job._exitcode, [0])

        let job = Job.start(['python3', path, '1'], options)
        Assert Equals(job.wait(), 1)
        Assert Equals(job._exitcode, [1])

        let job = Job.start(['python3', path, '2'], options)
        Assert Equals(job.wait(), 2)
        Assert Equals(job._exitcode, [2])
      End
    End

    Describe .id()
      It returns a unique number for individual process
        let path = Path.join(root, 'infinity_loop.py')
        let job1 = Job.start(['python3', path])
        let job2 = Job.start(['python3', path])
        Assert IsNumber(job1.id())
        Assert IsNumber(job2.id())
        Assert NotEqual(job1.id(), job2.id())
        call job1.stop()
        call job2.stop()
      End
    End

    Describe .status()
      It returns 'run' and 'dead' when the job alive or dead respectively
        let path = Path.join(root, 'infinity_loop.py')
        let job = Job.start(['python3', path])
        Assert Equals(job.status(), 'run')
        call job.stop()
        " Wait 1 sec to make sure the process termination
        sleep 1
        Assert Equals(job.status(), 'dead')
      End
    End

    Describe .send({data})
      It sends {data} (String) to the job process
        let path = Path.join(root, 'input.py')
        let job = Job.start(['python3', path])
        call job.send("lambdalisue\n")
        call job.wait()
        Assert Equals(job.status(), 'dead')
        Assert Equals(job.stdout.read(), ['Please input your name: Hello lambdalisue', ''])
        Assert Equals(job.stdout.read(), v:null)
      End

      It sends {data} (List) to the job process
        let path = Path.join(root, 'read.py')
        let job = Job.start(['python3', path])

        call job.send(['abc', "123\n456", ''])
        call job.send(['.', ''])
        call job.wait()
        Assert Equals(job.status(), 'dead')
        if has('nvim')
          Assert Equals(job.stdout.read(), [
                \ 'read:',
                \ 'abc',
                \ '123<NUL>456',
                \ '',
                \ '',
                \])
          Assert Equals(job.stdout.read(), v:null)
        else
          " Vim cannot send \0
          Assert Equals(job.stdout.read(), [
                \ 'read:',
                \ 'abc',
                \ '123456',
                \ '',
                \ '',
                \])
          Assert Equals(job.stdout.read(), v:null)
        endif
      End
    End

    Describe .stop()
      It stop a job which is running
        let path = Path.join(root, 'infinity_loop.py')
        let job = Job.start(['python3', path])
        Assert Equals(job.status(), 'run')
        call job.stop()
        " Wait 1 sec to make sure the process termination
        sleep 1
        Assert Equals(job.status(), 'dead')
        " The following should not raise exception
        call job.stop()
      End
    End

    Describe .wait([{timeout}])
      It waits a job to terminate
        let path = Path.join(root, '2sec.py')
        let job = Job.start(['python3', path])
        let start = reltime()
        let status = job.wait()
        let delta = reltime(start)
        Assert Equals(status, 0)
        Assert Equals(job.status(), 'dead')
        Assert Compare(reltimefloat(delta), '>', 2.0)
      End

      It returns an exit status when the job has terminated
        let path = Path.join(root, 'exitval.py')
        let job = Job.start(['python3', path, '0'])
        Assert Equals(job.wait(), 0)

        let job = Job.start(['python3', path, '1'])
        Assert Equals(job.wait(), 1)

        let job = Job.start(['python3', path, '2'])
        Assert Equals(job.wait(), 2)
      End

      It returns -1 when the job did not terminate within {timeout}
        let script = Path.join(root, 'infinity_loop.py')
        let job = Job.start(['python3', script])
        let start = reltime()
        let status = job.wait(10)
        let delta = reltime(start)
        Assert Equals(status, -1)
        Assert Equals(job.status(), 'run')
        Assert Compare(reltimefloat(delta), '>', 0.01)
        Assert Compare(reltimefloat(delta), '<', 0.02)
        " Kill the process
        call job.stop()
        " Wait 1 sec to make sure the process termination
        sleep 1
        Assert Equals(job.status(), 'dead')
      End
    End
  End
End
